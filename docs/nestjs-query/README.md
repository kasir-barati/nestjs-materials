# [`nestjs-query`](https://tripss.github.io/nestjs-query/)

- DRY -- querying, sorting and paging is handled by this lib.
- Easier time with CRUD operations in GraphQL.
- No [n+1 problem](https://github.com/kasir-barati/graphql-js-ts/blob/main/docs/nestjs.md#shouldWeUseResolveField).
- "[Connections](https://github.com/kasir-barati/graphql-js-ts/blob/main/docs/best-practices/pagination.md)" compliant pagination schema.

## `nestjs-query` + TypeORM + ExpressJS + PostgreSQL

1. ```shell
   pnpm add @ptc-org/nestjs-query-core @ptc-org/nestjs-query-graphql @ptc-org/nestjs-query-typeorm @nestjs/typeorm @nestjs/common @nestjs/graphql @nestjs/apollo @nestjs/config @apollo/server graphql graphql-subscriptions class-transformer class-validator dataloader typeorm pg
   ```
2. ```shell
   cd typeorm/apps/borprobe-nest
   nest g resource alert-type
   nest g resource alert
   ```
3. Open your `*.entity.ts` and modify it to use TypeORM and acts as you `Object` type.

   > [!TIP]
   >
   > It's always easy to merge your Custom Object Type defined for GraphQL with your persistence layer (in our case the entity we need for TypeORM). But it is no that easy to decouple them. But since here I am experimenting I will merge them from the get go. But you might wanna think twice before jumping into coding in a real world project.

4. For create we can use the one generated by `@ptc-org/nestjs-query-graphql` but it will have things like `id`, `createdAt`, and `updatedAt` which ain't required. So let's modify `dto/*.input.ts` to reflect our desired DTO.
5. Configure your NestJS app as it is described [here](https://github.com/kasir-barati/graphql-js-ts/blob/main/docs/nestjs.md).
6. [Config your TypeORM according to NestJS doc](https://docs.nestjs.com/techniques/database).
7. Config your `NestjsQueryGraphQLModule` for each module:

   ```ts
   import { Module } from "@nestjs/common";
   import { NestjsQueryGraphQLModule } from "@ptc-org/nestjs-query-graphql";
   import { NestjsQueryTypeOrmModule } from "@ptc-org/nestjs-query-typeorm";
   import { AlertTypeResolver } from "./alert-type.resolver";
   import { AlertTypeService } from "./alert-type.service";
   import { CreateAlertTypeInput } from "./dto/create-alert-type.input";
   import { AlertType } from "./entities/alert-type.entity";
   @Module({
     imports: [
       NestjsQueryGraphQLModule.forFeature({
         imports: [NestjsQueryTypeOrmModule.forFeature([AlertType])],
         resolvers: [
           {
             EntityClass: AlertType,
             DTOClass: AlertType,
             CreateDTOClass: CreateAlertTypeInput,
           },
         ],
       }),
     ],
     providers: [AlertTypeResolver, AlertTypeService],
   })
   export class AlertTypeModule {}
   ```

   > [!NOTE]
   >
   > No need for `TypeOrmModule.forFeature([AlertType]),` since `NestjsQueryTypeOrmModule` will register your entity with TypeORM.

8. Then we need to take care of `AppModule`, import and config:
   - `ConfigModule`.
   - `TypeOrmModule`.
   - `GraphQLModule`.
   - `AlertModule`.
   - `AlertTypeModule`.
9. Generate migration for TypeORM:

   ```shell
   nx migration:gen botprobe-nest --name init
   ```

10. Run the generated migrations:

    ```shell
    nx migration:run botprobe-nest
    ```

> [!TIP]
>
> Create new empty migration with:
>
> ```shell
> nx migration:create botprobe-nest  --name init
> ```

BTW I have written [a post for migration in TypeORM in dev.to here](https://dev.to/kasir-barati/nx-typeorm-nestjs-migrations-53an).
